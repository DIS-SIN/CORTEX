{
  "name": "Neo4jSurveySinkConnector",
  "config": {
    "topics": "survey_template,survey_response,nlp_result",
    "connector.class": "streams.kafka.connect.sink.Neo4jSinkConnector",
    "errors.retry.timeout": "-1",
    "errors.retry.delay.max.ms": "1000",
    "errors.tolerance": "all",
    "errors.log.enable": true,
    "errors.log.include.messages": true,
    "neo4j.server.uri": "bolt://192.168.86.41:7687",
    "neo4j.authentication.basic.username": "neo4j",
    "neo4j.authentication.basic.password": "##dis@da2019##",
    "neo4j.encryption.enabled": false,
    "neo4j.topic.cypher.survey_template": "WITH event, apoc.convert.fromJsonMap(event.content) AS c MERGE (s:Valhalla_Survey {uid: event.uid, format: event.format}) WITH s, c SET s.title = [c['title']['en'], c['title']['fr']], s.description = [c['description']['en'], c['description']['fr']], s.valid = [c['valid']['from'], c['valid']['to']], s.version = c['version'] WITH s, c['questions'] AS questions UNWIND questions AS cq WITH s, cq FOREACH (dummy IN CASE WHEN cq['qid'] <> 'none' THEN [1] ELSE [] END | MERGE (q:Valhalla_Question {uid: cq['cortex']['uid']}) FOREACH (dummy IN CASE WHEN cq['cortex']['questionType'] = 'SINGLE_CHOICE' THEN [1] ELSE [] END | SET q:SINGLE_CHOICE) FOREACH (dummy IN CASE WHEN cq['cortex']['questionType'] = 'MULTI_CHOICE' THEN [1] ELSE [] END | SET q:MULTI_CHOICE) FOREACH (dummy IN CASE WHEN cq['cortex']['questionType'] = 'FREE_TEXT' THEN [1] ELSE [] END | SET q:FREE_TEXT) SET q.type = cq['cortex']['questionType'], q.question = [cq['question']['en'], cq['question']['fr']], q.classified_as = cq['cortex']['classifiedAs'], q.options = apoc.convert.toJson(cq['options']) MERGE (q)<-[:AT_ORDER {n: cq['cortex']['atOrder']}]-(s) )",
    "neo4j.topic.cypher.survey_response": "WITH event, apoc.convert.fromJsonMap(event.content) AS c MERGE (s:Valhalla_Survey {uid: c['response']['conducted']}) MERGE (r:Valhalla_Response {uid: event.uid}) MERGE (r)-[:RESPOND_TO]->(s) SET r.survey_uid = c['response']['conducted'], r.content = event.content WITH r, c, c['respondent'] AS cr MERGE (d:Valhalla_Respondent {uid: r.uid}) FOREACH (dummy IN CASE WHEN cr.fluent_at IS NOT NULL THEN [1] ELSE [] END | MERGE (a:GC_Language {name: CASE WHEN TRIM(cr.fluent_at) = 'en' THEN 'English (Anglais)' ELSE 'FranÃ§ais (French)' END}) MERGE (d)-[:FLUENT_AT]->(a)) FOREACH (dummy IN CASE WHEN cr.located_in IS NOT NULL THEN [1] ELSE [] END | MERGE (p:CP_Province {uid: SPLIT(TRIM(SPLIT(cr.located_in, ',')[1]), ' ')[0]}) MERGE (a:CP_CSD {name: TRIM(SPLIT(cr.located_in, ',')[0])}) MERGE (a)-[:CSD_IN_PR]->(p) MERGE (d)-[:LOCATED_IN]->(a)) FOREACH (dummy IN CASE WHEN cr.in_department IS NOT NULL THEN [1] ELSE [] END | MERGE (a:GC_Org {en_name: TRIM(SPLIT(cr.in_department, '(')[0])}) MERGE (d)-[:IN_DEPARTMENT]->(a)) FOREACH (dummy IN CASE WHEN cr.work_as IS NOT NULL THEN [1] ELSE [] END | MERGE (a:GC_ClsLvl {uid: TRIM(cr.work_as)}) MERGE (d)-[:WORK_AS]->(a)) MERGE (d)-[:RESPONDENT_OF]->(r) SET r.created = [c['created']['from'], c['created']['to']] WITH r, c, c['questions'] AS questions UNWIND questions AS cq WITH r, c, cq MERGE (q:Valhalla_Question {uid: cq['uid']}) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.type = 'SINGLE_CHOICE' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, answer, apoc.map.get(map, answer, 0) + 1)), q.answer_total = answer_total + 1 MERGE (a:Valhalla_Answer {text: answer}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.type = 'MULTI_CHOICE' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, answer, apoc.map.get(map, answer, 0) + 1)), q.answer_total = answer_total + 1 FOREACH (dummy IN CASE WHEN q.type = 'MULTI_CHOICE' THEN [1] ELSE [] END | FOREACH (dummy IN CASE WHEN apoc.meta.type(answer) = 'STRING' THEN [1] ELSE [] END | MERGE (a:Valhalla_Answer {text: answer}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) FOREACH (dummy IN CASE WHEN apoc.meta.type(answer) = 'LIST' OR apoc.meta.type(answer) = 'STRING[]' THEN [1] ELSE [] END | FOREACH (c_answer IN answer | MERGE (a:Valhalla_Answer {text: c_answer}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) ) ) ) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.type = 'FREE_TEXT' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, answer, apoc.map.get(map, answer, 0) + 1)), q.answer_total = answer_total + 1 MERGE (a:Valhalla_Answer {text: answer}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.classified_as = 'GC_Org' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, TRIM(SPLIT(TRIM(SPLIT(answer, '(')[1]), ')')[0]), apoc.map.get(map, TRIM(SPLIT(TRIM(SPLIT(answer, '(')[1]), ')')[0]), 0) + 1)), q.answer_total = answer_total + 1 MERGE (a:GC_Org {en_name: TRIM(SPLIT(answer, '(')[0])}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.classified_as = 'GC_Language' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, answer, apoc.map.get(map, answer, 0) + 1)), q.answer_total = answer_total + 1 MERGE (a:GC_Language {name: answer}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.classified_as = 'GC_ClsLvl' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, answer, apoc.map.get(map, answer, 0) + 1)), q.answer_total = answer_total + 1 MERGE (a:GC_ClsLvl {uid: answer}) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) WITH r, c, cq, q, cq['questionAnswer'] AS answer, TOINTEGER(cq['atOrder']) AS at_order, CASE WHEN q.stats IS NULL THEN apoc.map.fromPairs([]) ELSE apoc.convert.fromJsonMap(q.stats) END AS map, CASE WHEN q.answer_total IS NULL THEN 0 ELSE q.answer_total END AS answer_total FOREACH (dummy IN CASE WHEN q.classified_as = 'CP_CSD' THEN [1] ELSE [] END | SET q.stats = apoc.convert.toJson(apoc.map.setKey(map, TRIM(SPLIT(answer, ',')[0]), apoc.map.get(map, TRIM(SPLIT(answer, ',')[0]), 0) + 1)), q.answer_total = answer_total + 1 MERGE (p:CP_Province {uid: SPLIT(TRIM(SPLIT(answer, ',')[1]), ' ')[0]}) MERGE (a:CP_CSD {name: TRIM(SPLIT(answer, ',')[0])}) MERGE (a)-[:CSD_IN_PR]->(p) MERGE (r)-[:AT_ORDER {n: at_order}]->(a) MERGE (a)-[:ANSWER_OF]->(q) ) WITH DISTINCT(r) AS r, c, COLLECT(DISTINCT(q)) AS qc WITH r, c, qc, REDUCE(m=[], q IN c['questions'] | CASE WHEN q['questionType'] = 'FREE_TEXT' THEN m + [apoc.map.fromPairs([['uid', q['uid']], ['text', q['questionAnswer']]])] ELSE m END) AS data WITH r, qc, apoc.map.fromPairs([['uid', r.uid], ['survey_uid', r.survey_uid], ['data', data]]) AS map CALL streams.publish('nlp_process', map) WITH r, REDUCE(m=[], q IN qc | m + [apoc.map.fromPairs([['uid', q.uid], ['total', q.answer_total], ['stats', q.stats], ['classifiedAs', q.classified_as], ['questionType', q.type], ['question', apoc.convert.toJson(q.question)]])]) AS data WITH r, apoc.map.fromPairs([['uid', r.uid], ['survey_uid', r.survey_uid], ['data', data]]) AS map CALL streams.publish('survey_metrics', map) RETURN 1",
    "neo4j.topic.cypher.nlp_result": "WITH event MERGE (r:Valhalla_Response {uid: event.uid}) SET r.sentiment = event.data"
  }
}
